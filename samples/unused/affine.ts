import { select } from "d3-selection";
// идея бескоординатного подхода в том, что вместо операций с
// координатами иы используем операции с точками и векторами
// которые короче и конятнее. Мы как бы на входе конвертируем
// координаты в вектора и точки и забываем про координаты
// а на выходе вспоминаем, в результате чего "посредине" координаты
// нигде не упоминаются
//
// Кроме того, "посредине" мы не можем создавать вектора и точки
// из ничего, а можем только комбинировать то, что взяли с собой
// вначале из мира координат.

// аффинное пространство состоит из точек и векторов
// но координатное представление у них одно
export type Vector = SVGPoint;

// единственный способ создавать объекты SVG API
// мы создаем только SVGPoint
const factory: SVGSVGElement = select("svg").node() as SVGSVGElement;

// функции "для входа"

export function newPoint(x: number, y: number): SVGPoint {
  const v = factory.createSVGPoint();
  v.x = x;
  v.y = y;
  return v;
}

export function newVector(x: number, y: number): Vector {
  return newPoint(x, y) as Vector;
}

export function identityTransform(): SVGMatrix {
  return factory.createSVGMatrix();
}

// ниже идут только функции из аффинного "сна"

// нулевой вектор
// он же нейтральный элемент при покоординатном сложении векторов
// вектора могут иметь разную природу, но по определению аффинного
// пространства должны образовывать группу. А по определению группы
// всегда должен быть нейтральный "нулевой" элемент
// такой что 0 + x == x + 0 == x
export const zeroV: Vector = newVector(0, 0);

// тут небольшая досада - по правилам аффинного сна мы можем
// умножать вектор на число, но комбинирование нулевого вектора
// с числами нам никаких новых векторов или точек не дает
// То есть, если ничего из точек и векторов с собой не брать
// то будет доступен только вот этот нулевой вектор (даже
// нулевая точка по правилам не полагается) который ни с чем не
// скомбинируешь.
//
// Идея "разрешённых" приемов аналогична разрешенным приемам при
// построениях с циркулем и линейкой, если вы помните со школы
// или игрались в них в онлайне
//
// Также оттуда же идея что можно использовать то что "взяли с собой"
// (в школьной геометрии например "дана высота и сторона треугольника")
// и что построили вокруг по разрешенным правилам.

// операция разности точек: точка - точка = вектор
export function pSubP(a: SVGPoint, b: SVGPoint): Vector {
  return newVector(a.x - b.x, a.y - b.y);
}

// разность точки и вектора: точка - вектор = точка
export function pSubV(p: SVGPoint, v: Vector): SVGPoint {
  return newVector(p.x - v.x, p.y - v.y);
}

// ещё разрешено умножение вектора на число, но мне лень
// писать поскольку я не использую
//
// Интересно что имея эти приемы можно написать
// сумму векторов, т.е. сумму векторов нет смысла включать
// как отдельный разрешённый приём. А вот сумму точек не напишешь.

// аффинное отображение является безкоординатным аналогом
// преобразования координат.
//
// аффинное отображение/трансформация трансформирует точки в точки
// и вектора в вектора. Но в SVG в готовом виде есть только
// трансформация точки. К счастью, имея аффинное пространство
// и отображение, трансформирующее только точки, трансформацию
// вектора мы можем написать
//
// Гипотетическая хаскельная сигнатура более понятна:
// AffineSpace s => (Point s -> Point s) -> (Vector s -> Vector s)
// в общем случае у нас может быть более одного вида
// пространств (например двумерные и трехмерные, или с векторами) и
// pSub и zeroV у каждого вида пространств свои. Одна и та же буква
// s в 4 местах означает что все 4 объекта (2 точки и 2 вектора) из
// одного и того же вида пространств
//
// Аффинные преобразования мы можем с собой приносить из мира координат
// или конструировать. Например имея вектор можно сконструировать
// параллельный перенос на него (и на него умноженного на число).
//

export function transformVector(
  transformPoint: (src: SVGPoint) => SVGPoint,
  vec: Vector,
): Vector {
  return pSubP(
    transformPoint(vec as SVGPoint),
    transformPoint(zeroV as SVGPoint),
  );
}
